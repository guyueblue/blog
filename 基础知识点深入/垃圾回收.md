```javascript
let sem = { name: "Semlinker" };
let array = [ sem ];
sem = null; // 覆盖引用

// sem 被存储在数组里, 所以它不会被垃圾回收机制回收
// 我们可以通过 array[0] 来获取它
```

https://time.geekbang.org/column/article/131233

## 垃圾回收基本流程（所有垃圾回收器的流程）

第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。

第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。

第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。

## 代际假说和分代收集

https://time.geekbang.org/column/article/131233

> 在 V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。
>
> 新生代垃圾回收算法——Scavenge 算法
>
> 老生代垃圾回收算法——标记 - 清除（Mark-Sweep）

### 1.代际假说

有以下两个特点：

1. 是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；
2. 是不死的对象，会活得更久。



### 2.分代收集

#### 为什么新老生代 需要不同的回收算法？

<img src="/Users/eleme/git/blog/基础知识点深入/垃圾回收.assets/image-20210618194411833.png" alt="image-20210618194411833" style="zoom:50%;" />



