# 算法理论

## 不变式
不变式（Invariant）是一个在程序执行过程中永远保持成立的条件。不变式在检测程序是否正确方面非常有用。例如编译器优化就用到了不变式。维基百科上用了MU puzzle的例子来证明不变式是非常有用的。

## 循环不变量
> 变量的值是变化的，在变化中保持不变的性质就称为循环不变量。

循环不变式（Loop Invariant）是在循环的第一次迭代前、循环中的每一次迭代和循环结束后都为真的不变式。也可以将循环不变式看作是一个逻辑断言。

> 循环不变式主要用来帮助我们理解算法的正确性。关于循环不变式，我们必须证明三条性质：
>初始化：循环的第一次迭代之前，它为真。
>保持：如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真。
>终止：在循环终止时，不变式为我们提供一个有用的性质，该性质有助于证明算法是正确的。

### 作用
明确循环不变量，可以帮助我们 理清楚变量的含义、变量的初始化的值、在循环的过程中操作的先后顺序以及在循环完成以后实现了怎样的效果，返回的变量的值是多少。

### 例子-二分查找
```
function binarySearch(arr, target) {
    let low = 0;
    let high = arr.length - 1;

    while (low <= high) {
        const mid = Math.floor((low + high) / 2);
        const guess = arr[mid];

        if (guess === target) {
            return mid; // 找到目标值，返回其索引
        }
        if (guess < target) {
            low = mid + 1; // 目标值在中间值的右侧
        } else {
            high = mid - 1; // 目标值在中间值的左侧
        }
    }

    return -1; // 未找到目标值，返回-1
}
```
循环不变量解释
> 这段二分查找代码的循环不变量可以定义为：在每次循环开始时，如果目标值在数组中，则它必定位于索引 low 和 high 之间（包括low 和 high）的子数组中。

证明：

1. 初始化（Initialization）: 在循环开始之前，low 被初始化为 0（数组的起始索引），high 被初始化为 arr.length - 1（数组的末尾索引）。因此，如果目标值在数组中，它一定在这个初始的搜索范围内。所以循环不变量在第一次迭代之前成立。

2. 保持（Maintenance）: 假设循环不变量在进入循环时为真。根据mid的值将搜索区间减半（不包括mid），并且根据与target的比较结果更新low或high的值。因此，如果目标值在数组中，更新后的low和high依然会界定一个包含目标值的子数组。这确保了循环不变量在每次迭代后依然成立。

3. 终止（Termination）: 循环的终止条件是low大于high。当循环终止时，根据循环不变量，我们知道目标值如果在数组中，它应该位于索引low和high之间的子数组中。但由于low已经超过了high，这意味着这个子数组不存在，所以我们可以得出目标值不在数组中的结论，并返回-1。

通过这种方式，循环不变量帮助我们理解了二分查找的工作原理，并证明了它的正确性。在每次迭代过程中，搜索的范围都在缩小，直到找到目标值或者范围无法再缩小（即low > high），这时算法结束


