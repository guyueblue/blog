#基础

## 1. JavaScript 继承

![image-20200316155135642](assets/image-20200316155135642.png)

## 2. 创建长度为 100 的数组

```javascript
//错误解法
Array(100).map((v,i)=> i) //创建100 内存空间，但无值
```

传统方法

```javascript
var arr = new Array(100)
for (var i = 0; i < arr.length; i++) {
  arr[i] = i;
}
arr;
```

es5

```javascript
Object.keys(Array.from({ length: 100 }));  
Object.keys(Array.apply(null,{ length: 100 }));

//Object.keys 返回是 string

Object.keys(Array.apply(null, {length: 100})).map(function(item){
  return ++item;
})
```



es6

```javascript
//Array.from() 方法从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例
Array.from(new Array(100).keys())

//keys() 方法返回一个包含数组中每个索引键的Array Iterator对象。
[...Array(100).keys()]
[...Array.from({length:100}).keys()]

```



## [3.JS 对象之扩展、密封及冻结三大特性](https://segmentfault.com/a/1190000003894119)



## [HTTP状态码详解](https://www.jianshu.com/p/93555718732a)

##### 1xx：信息性状态码，表示服务器已接收了客户端请求，客户端可继续发送请求。

##### 2xx：成功状态码，表示服务器已成功接收到请求并进行处理

- 200（OK/正常）：返回正常
- 206 (Partial Content/局部内容)： eg 下载文件

##### 3xx：重定向  -——用户已经移动的文件并且常被包含在定位头信息中指定的新的地址信息

301（Moved Permanently）：永久重定向

302（Found/找到）：临时重定向

304（Not Modified/为修正）：协商缓存

##### 4xx：用户指定客户端的错误

401（Unauthorized/未授权）：表示客户端在授权头信息中没有有效的身份信息时，访问收到密码保护的页面。这个授权必须包含一个WWW-Authenticate的授权信息头

403（Forbidden/禁止）：

404（Not Found）：无法找到资源

##### 5xx：用户指定服务器的错误

- 500 (Internal Server Error/内部服务器错误)：是常用的“服务器错误”状态。该状态经常由CGI程序引起也可能（但愿不会如此！）由无法正常运行的或返回头信息格式不正确的servlet引起。
- 501 (Not Implemented/未实现)：告诉客户端服务器不支持请求中要求的功能。例如，客户端执行了如PUT这样的服务器并不支持的命令。



# 代码实现

## [JavaScript深入之new的模拟实现](https://github.com/mqyqingfeng/Blog/issues/13)







# 原理

## react

###1.[React Fiber](https://zhuanlan.zhihu.com/p/26027085)

同步更新过程的局限

> 当React决定要加载或者更新组件树时，会做很多事，比如调用各个组件的生命周期函数，计算和比对Virtual DOM，最后更新DOM树，这整个过程是同步进行的，也就是说只要一个加载或者更新过程开始，那React就以不破楼兰终不还的气概，一鼓作气运行到底，中途绝不停歇



## Vue

### 1.[v-model](https://www.jianshu.com/p/557418b683a9)

####表单元素

![image-20200307002248244](assets/image-20200307002248244.png)

1. 添加 :value
2. 添加 $input

####组件

![image-20200307002956529](assets/image-20200307002956529.png)



#### [model](https://cn.vuejs.org/v2/api/#model)





## webpack

#### 1. Long term caching

> 难点：
>
> 1. 路径持久化
> 2. 内容持久化 Module id与Chunk id 都是自增的，所以方案是转换为 路径，或者路径hash

[用 webpack 实现持久化缓存](https://sebastianblade.com/using-webpack-to-achieve-long-term-cache/)

 [hash]：此次打包的所有内容的 hash。
[chunkhash]：每一个 chunk 都根据自身的内容计算而来。
[contenthash]：由 css 提取插件提供，根据自身内容计算得来。

Module vs Chunk

- HashedModuleIdsPlugin  NamedModulesPlugin

- NamedChunksPlugin   HashdChunksPlugin

- ### RuntimeChunk——[optimization.runtimeChunk](https://segmentfault.com/q/1010000014954264)

> NamedChunksPlugin 只对有 **name** 的 chunk 才奏效！所以我们那些异步懒加载的页面都是无效的

`NamedChunksPlugin`支持自己写 nameResolver 的规则的。但目前大部分相关的文章里的自定义函数是不适合 webpack4 ，而且在结合 vue 的情况下还会报错。

社区旧方案：

```
new webpack.NamedChunksPlugin(chunk => {
  if (chunk.name) {
    return chunk.name;
  }
  return chunk.modules.map(m => path.relative(m.context, m.request)).join("_");
});
复制代码
```

适配 webpack4 和 vue 的新实现方案：

```
new webpack.NamedChunksPlugin(chunk => {
  if (chunk.name) {
    return chunk.name;
  }
  return Array.from(chunk.modulesIterable, m => m.id).join("_");
});
```


作者：花裤衩
链接：https://juejin.im/post/5b5d6d6f6fb9a04fea58aabc
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



## 





# http

## 1. 缓存

![image-20200314163322764](assets/image-20200314163322764.png)

### 强制缓存：

1. cache-control 和 max-age ——  http 1.1 定义的，意义是缓存多少毫秒，可以覆盖 expires

2. ### expires —— 缓存多久

### 协商缓存

1. ETag —— 文件hash  （缺点：需要每次改变耗费cpu算） 【优先级高】

2. Last-Modified 的区别  —— 上次修改时间 （缺点：精确到秒）

   

   

## 2.[三次握手，四次挥手](https://juejin.im/post/5d9c284b518825095879e7a5)

### 1). 为什么需要三次握手，两次不行吗？（接受，发送）

> 重点是 需要各自确认（接受，发送）
>
> 需要三次握手才能确认双方的接收与发送能力是否正常

## 3.url输入后

```
网络（请求与响应）
浏览器渲染过程
```

### 1）网络（请求与响应）

过程：

1.DNS域名解析；
2.建立TCP连接；（3次握手，为什么三次握手）
3.发送HTTP请求；
4.服务器处理请求；
5.返回响应结果；
6.关闭TCP连接；

### 2）浏览器渲染过程

​	- 解析dom

​	- 请求css,js，图片资源。并行，有限制

 - 执行js，css会阻塞渲染和加载。

   

[原来 CSS 与 JS 是这样阻塞 DOM 解析和渲染的](https://github.com/ljf0113/how-js-and-css-block-dom)

defer和async

![image-20200315205727185](assets/image-20200315205727185.png)



## 4. [网络安全](https://github.com/YvetteLau/Blog/issues/29)



## 5.https





# ES6

## 1.[Proxy、Reflect](https://zhuanlan.zhihu.com/p/30299114)

**Proxy的函数负责的是：拦截并定义拦截时具体的操作；Reflect的静态函数负责的是：最终执行对象的操作**



## 2. Iterator（遍历器）的概念

Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令`for...of`循环，Iterator 接口主要供`for...of`消费。

`next`方法



## 3. [ES6 模块与 CommonJS 模块的差异]([https://es6.ruanyifeng.com/#docs/module-loader#ES6-%E6%A8%A1%E5%9D%97%E4%B8%8E-CommonJS-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B7%AE%E5%BC%82](https://es6.ruanyifeng.com/#docs/module-loader#ES6-模块与-CommonJS-模块的差异))

- CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
- CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

## 4. [Object.creat vs {}](https://juejin.im/post/5acd8ced6fb9a028d444ee4e#heading-2)

